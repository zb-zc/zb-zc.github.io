<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="应用程序函数在对应的驱动中都有之相对应的函数，每一个系统调用，在驱动中都有之对应的一个驱动函数。在linux内核文件include&#x2F;linux&#x2F;fs.h中有个叫做file_operations的结构体，此结构体就是linux内核驱动操作函数集合明确几个概念：      系统调用：内核的接口被称为系统调用，公用的函数库构建在系统调用接口之上，应用程序既可以使用公共函数库也可以使用">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式">
<meta property="og:url" content="http://example.com/2022/05/06/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="嵌入式">
<meta property="og:description" content="应用程序函数在对应的驱动中都有之相对应的函数，每一个系统调用，在驱动中都有之对应的一个驱动函数。在linux内核文件include&#x2F;linux&#x2F;fs.h中有个叫做file_operations的结构体，此结构体就是linux内核驱动操作函数集合明确几个概念：      系统调用：内核的接口被称为系统调用，公用的函数库构建在系统调用接口之上，应用程序既可以使用公共函数库也可以使用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-06T11:06:45.606Z">
<meta property="article:modified_time" content="2022-05-06T11:05:21.000Z">
<meta property="article:author" content="赵博">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/05/06/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/05/06/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","path":"2022/05/06/字符设备驱动/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | 嵌入式</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">嵌入式</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录每一次成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">0</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">0</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">3</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.</span> <span class="nav-text">字符设备驱动的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">字符设备驱动模块的加载与卸载</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">赵博</p>
  <div class="site-description" itemprop="description">果淉菓</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/06/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="赵博">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式">
      <meta itemprop="description" content="果淉菓">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 嵌入式">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-06 19:06:45 / 修改时间：19:05:21" itemprop="dateCreated datePublished" datetime="2022-05-06T19:06:45+08:00">2022-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>应用程序函数在对应的驱动中都有之相对应的函数，每一个系统调用，在驱动中都有之对应的一个驱动函数。在linux内核文件include&#x2F;linux&#x2F;fs.h中有个叫做file_operations的结构体，此结构体就是linux内核驱动操作函数集合</strong><br><strong>明确几个概念：</strong>    </p>
<ol>
<li>系统调用：内核的接口被称为系统调用，公用的函数库构建在系统调用接口之上，应用程序既可以使用公共函数库也可以使用系统调用  </li>
<li>字符设备就是一个一个字节，按照字节流进行读写操作的设备。比如我们最常见的点灯、按键、 IIC、 SPI，LCD*  等等都是字符设备</li>
</ol>
<h1 id="字符设备驱动的组成"><a href="#字符设备驱动的组成" class="headerlink" title="字符设备驱动的组成"></a>字符设备驱动的组成</h1><h4 id="字符设备驱动模块的加载与卸载"><a href="#字符设备驱动模块的加载与卸载" class="headerlink" title="字符设备驱动模块的加载与卸载"></a>字符设备驱动模块的加载与卸载</h4><p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev的注册，而在卸载函数中应实现设备号的释放和cdev的注销  </p>
<ol>
<li><p><strong>字符设备驱动模块加载与卸载函数模板</strong>  </p>
<pre><code> struct globalmem_dev &#123;
 struct cdev cdev;
 unsigned char mem[GLOBALMEM_SIZE];
 &#125;;

 struct globalmem_dev *globalmem_devp;

 static int __init globalmem_init(void)
 &#123;
 
 &#125;
 module_init(globalmem_init);

 static void __exit globalmem_exit(void)
 &#123;
 cdev_del(&amp;globalmem_devp-&gt;cdev);
 kfree(globalmem_devp);

 &#125;
 module_exit(globalmem_exit);

 MODULE_AUTHOR(&quot;Barry Song &lt;baohua@kernel.org&gt;&quot;);
 MODULE_LICENSE(&quot;GPL v2&quot;);
</code></pre>
</li>
<li><p><strong>分配和释放设备号</strong><br>解决这两个问题最好的方法就是要使用设备号的时候向 Linux内核申请，需要几个就申请几个，由 Linux内核分配设备可以使用的设备号。   </p>
<pre><code> //MKDEV来构建设备号，次设备号选择 0。
 dev_t devno = MKDEV(globalmem_major, 0);
 //注册设备号；静态or动态
 if (globalmem_major)
     ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);

 else &#123;
     ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;);
     globalmem_major = MAJOR(devno);
 &#125;
</code></pre>
</li>
</ol>
<p>释放  </p>
<pre><code>unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);
</code></pre>
<ol start="3">
<li><strong>字符设备注册方法</strong></li>
</ol>
<ul>
<li><p>cdev结构体<br>在linux内核中使用cdev结构体描述一个字符设备，cdev结构体的定义如下所示</p>
<pre><code>  &lt;include/linux/cdev.h&gt;
  struct cdev &#123; 
  struct kobject kobj;                  //内嵌的内核对象.
  struct module *owner;                 //该字符设备所在的内核模块的对象指针.
  const struct file_operations *ops;    //该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.
  struct list_head list;                //用来将已经向内核注册的所有字符设备形成链表.
  dev_t dev;                            //字符设备的设备号，由主设备号和次设备号构成.
      unsigned int count;                   //隶属于同一主设备号的次设备号的个数.
  &#125;    
</code></pre>
</li>
<li><p>cdev_init函数<br>定义好 cdev变量以后就要使用 cdev_init函数对其进行初始化， cdev_init函数原型如下：  </p>
<pre><code>  void cdev_init(struct cdev *cdev, const struct file_operations *fops)
</code></pre>
<p>  使用cdev_init初始化cdev结构体变量  </p>
<pre><code>  struct cdev testcdev; 
  /* 设备操作函数 */ 
   static struct file_operations test_fops = &#123;
  .owner = THIS_MODULE, 
   /* 其他具体的初始项 */ 
   &#125;;
  
  testcdev.owner = THIS_MODULE;
  cdev_init(&amp;testcdev, &amp;test_fops); /* 初始化cdev结构体变量 */  
</code></pre>
</li>
<li><p>cdev_add 函数<br>cdev_add函数用于向 Linux系统添加字符设备 (cdev结构体变量 )，首先使用 cdev_init函数，完成对cdev结构体变量的初始化，然后使用 cdev_add函数向 Linux系统添加这个字符设备。 cdev_add函数原型如下：  </p>
<pre><code>  int cdev_add(struct cdev *p, dev_t dev, unsigned count)
</code></pre>
</li>
</ul>
<p>参数 p指向要添加的字符设备 (cdev结构体变量 )，参数 dev就是设备所使用的设备号，参数 count是要添加的设备数量。 </p>
<ul>
<li><p>cdev_del函数  </p>
<pre><code>  void cdev_del(struct cdev *p)
</code></pre>
</li>
</ul>
<p>4.<strong>自动创建设备节点</strong><br>使用 busybox构建根文件系统的时候， busybox会创建一个 udev的简化版本 mdev，所以在嵌入式 Linux中我们使用mdev来实现设备节点文件的自动创建与删除， Linux系统中的热 插拔事件也由 mdev管理。</p>
<ul>
<li><p>创建和删除类<br>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在<strong>cdev_add函数</strong>后面添加自动创建设备节点相关代码。首先要创建一个class类  </p>
<pre><code>  struct class *class_create (struct module *owner, const char *name)  
</code></pre>
<p>  &#x2F;&#x2F;class_create一共有两个参数，参数 owner一般为 THIS_MODULE，参数 name是类名字。返回值是个指向结构体 class的指针，也就是创建的类。</p>
</li>
</ul>
<p>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：  </p>
<pre><code>    void class_destroy(struct class *cls);  
</code></pre>
<ul>
<li><p>创建设备<br>上一小节创建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设备。使用 device_create函数在类下面创建设备。  </p>
<pre><code>  struct device *device_create(struct class *class, 
                  struct device *parent, 
                  dev_t devt, 
                  void *drvdata, 
                  const char *fmt, ...)  
  参数 class就是设备要创建哪个类下面；
  参数 parent是父设备，一般为 NULL，也就是没有父设备；
  参数 devt是设备号；
  参数 drvdata是设备可能会使用的一些数据，一般为 NULL；
  参数 fmt是设备名字，如果设置 fmt=xxx的话，就会生成 /dev/xxx这个设备文件。
  返回值就是创建好的设备。
</code></pre>
</li>
</ul>
<p>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型   </p>
<pre><code>void device_destroy(struct class *class, dev_t devt)  
</code></pre>
<ol start="5">
<li><p><strong>设置文件私有属性</strong><br>每个硬件设备都有一些属性，比如主设备号 (dev_t)，类 (class)、设备 (device)、开关状态 (state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式，对于一个设备的所有属性信息我们最好将其做成一个结构体。成一个结构体。编写驱动open函数的时候将设备结构体作为私有数据添加到设备文件中，如下  </p>
<pre><code> struct test_dev&#123;  dev_t devid; /* 设备号 */ 
                     struct cdev cdev; /* cdev */ 
                     struct class *class; /* 类 */ 
                     struct device *device; /* 设备 */ 
                     int major; /* 主设备号 */ 
                     int minor; /* 次设备号 */ 
                      &#125;;  
</code></pre>
<p> <strong>在 open函数里面设置好私有数据以后，在 write、 read、 close等函数中直接读取 private_data即可得到设备结构体。</strong></p>
</li>
<li><p><strong>字符设备驱动的file_operations结构体中的成员函数</strong><br>字符设备驱动的file_operations结构体中的成员函数是字符设备驱动函数与内核虚拟文件系统的接口，是用户空间对Linux进行系统调用的最终落实着</p>
</li>
</ol>
<p><strong>模板</strong>  </p>
<pre><code>    static int globalmem_open(struct inode *inode, struct file *filp)
    &#123;
    filp-&gt;private_data = globalmem_devp;
    return 0;
    &#125;

    static int globalmem_release(struct inode *inode, struct file *filp)
    &#123;
    return 0;
    &#125;

    static long globalmem_ioctl(struct file *filp, unsigned int cmd,
            unsigned long arg)
    &#123;
    struct globalmem_dev *dev = filp-&gt;private_data;

    switch (cmd) &#123;
        case MEM_CLEAR:
        memset(dev-&gt;mem, 0, GLOBALMEM_SIZE);
        printk(KERN_INFO &quot;globalmem is set to zero\n&quot;);
        break;

        default:
        return -EINVAL;
    &#125;

    return 0;
    &#125;

    static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size,loff_t * ppos)  
    &#123;
    unsigned long p = *ppos;
    unsigned int count = size;
    int ret = 0;
    struct globalmem_dev *dev = filp-&gt;private_data;

    if (p &gt;= GLOBALMEM_SIZE)
    return 0;
    if (count &gt; GLOBALMEM_SIZE - p)
    count = GLOBALMEM_SIZE - p;

    if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123;
    ret = -EFAULT;
    &#125; else &#123;
    *ppos += count;
    ret = count;

    printk(KERN_INFO &quot;read %u bytes(s) from %lu\n&quot;, count, p);
    &#125;

    return ret;
    &#125;

    static ssize_t globalmem_write(struct file *filp, const char __user * buf,
               size_t size, loff_t * ppos)
    &#123;
    unsigned long p = *ppos;
    unsigned int count = size;
    int ret = 0;
    struct globalmem_dev *dev = filp-&gt;private_data;

    if (p &gt;= GLOBALMEM_SIZE)
    return 0;
    if (count &gt; GLOBALMEM_SIZE - p)
    count = GLOBALMEM_SIZE - p;

    if (copy_from_user(dev-&gt;mem + p, buf, count))
    ret = -EFAULT;
    else &#123;
    *ppos += count;
    ret = count;

    printk(KERN_INFO &quot;written %u bytes(s) from %lu\n&quot;, count, p);
    &#125;

    return ret;
    &#125;

    static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)
    &#123;
    loff_t ret = 0;
    switch (orig) &#123;
    case 0:
    if (offset &lt; 0) &#123;
        ret = -EINVAL;
        break;
    &#125;
    if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123;
        ret = -EINVAL;
        break;
    &#125;
    filp-&gt;f_pos = (unsigned int)offset;
    ret = filp-&gt;f_pos;
    break;
    case 1:
    if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123;
        ret = -EINVAL;
        break;
    &#125;
    if ((filp-&gt;f_pos + offset) &lt; 0) &#123;
        ret = -EINVAL;
        break;
    &#125;
    filp-&gt;f_pos += offset;
    ret = filp-&gt;f_pos;
    break;
    default:
    ret = -EINVAL;
    break;
    &#125;
    return ret;
     &#125;

    static const struct file_operations globalmem_fops = &#123;
    .owner = THIS_MODULE,
    .llseek = globalmem_llseek,
    .read = globalmem_read,
    .write = globalmem_write,
    .unlocked_ioctl = globalmem_ioctl,
    .open = globalmem_open,
    .release = globalmem_release,
     &#125;;
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/02/uboot/" rel="prev" title="uboot 基础">
                  <i class="fa fa-chevron-left"></i> uboot 基础
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵博</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
